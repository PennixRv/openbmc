From fb5a43cc26a75b897c37ec4202a5aba57b87e019 Mon Sep 17 00:00:00 2001
From: Dylan Hung <dylan_hung@aspeedtech.com>
Date: Fri, 27 Oct 2023 17:42:22 +0800
Subject: [PATCH] feat(ast2700): add SLI calibration

The AST2700 SoC embeds two dies, the CPU-die and IO-die, and uses a
serial bus (SLI) to connect these two dies. This commit speeds up the
upstream direction (from IO-die to CPU-die) to 500MHz and calibrates the
RX tap delay.

Signed-off-by: Dylan Hung <dylan_hung@aspeedtech.com>
---
 plat/aspeed/ast2700/include/platform_reg.h |  59 +++++
 plat/aspeed/ast2700/plat_bl31_setup.c      | 276 +++++++++++++++++++++
 plat/aspeed/ast2700/platform.mk            |   2 +
 3 files changed, 337 insertions(+)

diff --git a/plat/aspeed/ast2700/include/platform_reg.h b/plat/aspeed/ast2700/include/platform_reg.h
index 7f268654cfca..8e1dcb23735a 100644
--- a/plat/aspeed/ast2700/include/platform_reg.h
+++ b/plat/aspeed/ast2700/include/platform_reg.h
@@ -24,4 +24,63 @@
 #define SCU_CPU_SMP_EP2	(SCU_CPU_BASE + 0x790)
 #define SCU_CPU_SMP_EP3	(SCU_CPU_BASE + 0x798)
 
+/* CPU-die SLI */
+#define SLI_CPU_BASE			0x12c17000
+#define SLIM_CPU_BASE			(SLI_CPU_BASE + 0x000)
+#define SLIH_CPU_BASE			(SLI_CPU_BASE + 0x200)
+#define SLIV_CPU_BASE			(SLI_CPU_BASE + 0x400)
+
+/* IO-die SLI */
+#define SLI_IOD_BASE			0x14c1e000
+#define SLIM_IOD_BASE			(SLI_IOD_BASE + 0x000)
+#define SLIH_IOD_BASE			(SLI_IOD_BASE + 0x200)
+#define SLIV_IOD_BASE			(SLI_IOD_BASE + 0x400)
+
+#define SLI_CTRL_I			0x00
+#define   SLIV_RAW_MODE			BIT(15)
+#define   SLI_TX_MODE			BIT(14)
+#define   SLI_RX_PHY_LAH_SEL_REV	BIT(13)
+#define   SLI_RX_PHY_LAH_SEL_NEG	BIT(12)
+#define   SLI_AUTO_SEND_TRN_OFF		BIT(8)
+#define   SLI_CLEAR_BUS			BIT(6)
+#define   SLI_TRANS_EN			BIT(5)
+#define   SLI_CLEAR_RX			BIT(2)
+#define   SLI_CLEAR_TX			BIT(1)
+#define   SLI_RESET_TRIGGER		BIT(0)
+#define SLI_CTRL_II			0x04
+#define   SLIV_TX_ENT_SUSPEND		GENMASK(15, 14)
+#define SLI_CTRL_III			0x08
+#define   SLI_PHYCLK_SEL		GENMASK(27, 24)
+#define     SLI_PHYCLK_800M		0x1
+#define     SLI_PHYCLK_400M		0x2
+#define     SLI_PHYCLK_200M		0x3
+#define     SLI_PHYCLK_1G		0x5
+#define     SLI_PHYCLK_500M		0x6
+#define   SLIH_PAD_DLY_TX1		GENMASK(23, 18)
+#define   SLIH_PAD_DLY_TX0		GENMASK(17, 12)
+#define   SLIH_PAD_DLY_RX1		GENMASK(11, 6)
+#define   SLIH_PAD_DLY_RX0		GENMASK(5, 0)
+#define   SLIM_PAD_DLY_RX3		GENMASK(23, 18)
+#define   SLIM_PAD_DLY_RX2		GENMASK(17, 12)
+#define   SLIM_PAD_DLY_RX1		GENMASK(11, 6)
+#define   SLIM_PAD_DLY_RX0		GENMASK(5, 0)
+#define   SLIV_PAD_DLY_TX1		GENMASK(23, 18)
+#define   SLIV_PAD_DLY_TX0		GENMASK(17, 12)
+#define   SLIV_PAD_DLY_RX1		GENMASK(11, 6)
+#define   SLIV_PAD_DLY_RX0		GENMASK(5, 0)
+
+#define SLI_INTR_STATUS			0x14
+#define   SLI_INTR_RX_SYNC		BIT(15)
+#define   SLI_INTR_RX_ERR		BIT(13)
+#define   SLI_INTR_RX_NACK		BIT(12)
+#define   SLI_INTR_RX_TRAIN_PKT		BIT(10)
+#define   SLI_INTR_RX_DISCONN		BIT(6)
+#define   SLI_INTR_TX_SUSPEND		BIT(4)
+#define   SLI_INTR_TX_TRAIN		BIT(3)
+#define   SLI_INTR_TX_IDLE		BIT(2)
+#define   SLI_INTR_RX_SUSPEND		BIT(1)
+#define   SLI_INTR_RX_IDLE		BIT(0)
+#define   SLI_INTR_RX_ERRORS                                                     \
+	  (SLI_INTR_RX_ERR | SLI_INTR_RX_NACK | SLI_INTR_RX_DISCONN)
+
 #endif /* PLATFORM_REG_H */
diff --git a/plat/aspeed/ast2700/plat_bl31_setup.c b/plat/aspeed/ast2700/plat_bl31_setup.c
index fde5dbbc6f14..2e7f7821faa3 100644
--- a/plat/aspeed/ast2700/plat_bl31_setup.c
+++ b/plat/aspeed/ast2700/plat_bl31_setup.c
@@ -10,11 +10,24 @@
 #include <drivers/arm/gicv3.h>
 #include <drivers/console.h>
 #include <drivers/ti/uart/uart_16550.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/delay_timer.h>
 #include <lib/mmio.h>
 #include <lib/xlat_tables/xlat_tables_v2.h>
 #include <plat/common/platform.h>
 #include <platform_def.h>
 
+#define __bf_shf(x) (__builtin_ffsll(x) - 1)
+#define FIELD_PREP(_mask, _val)						\
+	({								\
+		((typeof(_mask))(_val) << __bf_shf(_mask)) & (_mask);	\
+	})
+
+#define FIELD_GET(_mask, _reg)						\
+	({								\
+		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
+	})
+
 static console_t console;
 
 static entry_point_info_t bl32_ep_info;
@@ -45,6 +58,10 @@ static const mmap_region_t plat_mmap[] = {
 			MT_DEVICE | MT_RW | MT_SECURE),
 	MAP_REGION_FLAT(SCU_CPU_BASE, PAGE_SIZE,
 			MT_DEVICE | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(SLI_CPU_BASE, PAGE_SIZE,
+			MT_DEVICE | MT_RW | MT_SECURE),
+	MAP_REGION_FLAT(SLI_IOD_BASE, PAGE_SIZE,
+			MT_DEVICE | MT_RW | MT_SECURE),
 	{ 0 }
 };
 
@@ -86,8 +103,267 @@ void bl31_plat_arch_setup(void)
 	enable_mmu_el3(0);
 }
 
+static int sli_wait(uint32_t base, uint32_t mask)
+{
+	uint32_t value;
+
+	mmio_write_32(base + SLI_INTR_STATUS, 0xffffffff);
+
+	do {
+		value = mmio_read_32(base + SLI_INTR_STATUS);
+		if (value & SLI_INTR_RX_ERRORS)
+			return -1;
+	} while ((value & mask) != mask);
+
+	return 0;
+}
+
+static int sli_wait_suspend(uint32_t base)
+{
+	return sli_wait(base, SLI_INTR_TX_SUSPEND | SLI_INTR_RX_SUSPEND);
+}
+
+static int is_sli_suspend(uint32_t base)
+{
+	uint32_t value;
+	uint32_t suspend = SLI_INTR_TX_SUSPEND | SLI_INTR_RX_SUSPEND;
+
+	value = mmio_read_32(base + SLI_INTR_STATUS);
+	if (value & SLI_INTR_RX_ERRORS)
+		return -1;
+	else if ((value & suspend) == suspend)
+		return 1;
+	else
+		return 0;
+}
+
+static void bl31_plat_sli_init(void)
+{
+	uint32_t reg;
+	int d0, d1;
+	int i, d0_start = -1, d0_end = -1;
+	int win[32][2];
+
+	/* early return if SLI had been calibrated */
+	reg = mmio_read_32(SLIH_IOD_BASE + SLI_CTRL_III);
+	reg = FIELD_GET(SLI_PHYCLK_SEL, reg);
+	if (reg)
+		return;
+
+	/* CPU SLI training off */
+	reg = SLI_AUTO_SEND_TRN_OFF | SLI_TRANS_EN;
+	mmio_write_32(SLIM_CPU_BASE + SLI_CTRL_I, reg);
+	mmio_write_32(SLIH_CPU_BASE + SLI_CTRL_I, reg);
+
+	reg |= SLIV_RAW_MODE;
+	mmio_write_32(SLIV_CPU_BASE + SLI_CTRL_I, reg);
+
+	/* change IOD SLIH PHY clock to 500M */
+	reg = mmio_read_32(SLIH_IOD_BASE + SLI_CTRL_III);
+	reg |= FIELD_PREP(SLI_PHYCLK_SEL, SLI_PHYCLK_500M);
+	mmio_write_32(SLIH_IOD_BASE + SLI_CTRL_III, reg);
+	udelay(10);
+
+	for (i = 0; i < 32; i++) {
+		win[i][0] = -1;
+		win[i][1] = -1;
+	}
+
+	/* Calibrate CPU-SLIH US pad delay */
+	for (d0 = 0; d0 < 16; d0++) {
+		for (d1 = 0; d1 < 16; d1++) {
+			/* Adjust pad delay */
+			reg = mmio_read_32(SLIH_CPU_BASE + SLI_CTRL_III);
+			reg &= ~(SLIH_PAD_DLY_RX1 | SLIH_PAD_DLY_RX0);
+			reg |= FIELD_PREP(SLIH_PAD_DLY_RX1, d1) |
+			       FIELD_PREP(SLIH_PAD_DLY_RX0, d0);
+			mmio_write_32(SLIH_CPU_BASE + SLI_CTRL_III, reg);
+
+			/*
+			 * CPU SLIH
+			 * clr bit[8] -> enable training,
+			 * clr bit[12] -> disable LAH_SEL_NEG
+			 * set bit[2] -> clear RX
+			 */
+			mmio_write_32(SLIH_CPU_BASE + SLI_CTRL_I,
+				      SLI_TRANS_EN | SLI_CLEAR_RX);
+			udelay(10);
+
+			/* check interrupt status */
+			mmio_write_32(SLIH_CPU_BASE + SLI_INTR_STATUS, 0xffffffff);
+			if (is_sli_suspend(SLIH_CPU_BASE)) {
+				if (win[d0][0] == -1)
+					win[d0][0] = d1;
+
+				win[d0][1] = d1;
+			} else if (win[d0][1] != -1) {
+				break;
+			}
+		}
+	}
+
+	d0_start = -1;
+	d0_end = -1;
+	for (i = 0; i < 32; i++) {
+		if (win[i][0] != -1) {
+			if (d0_start == -1)
+				d0_start = i;
+
+			d0_end = i;
+		} else if (d0_end != -1) {
+			break;
+		}
+	}
+
+	d0 = (d0_start + d0_end) >> 1;
+	d1 = (win[d0][0] + win[d0][1]) >> 1;
+
+	/* load the calibrated delay values */
+	mmio_write_32(SLIH_CPU_BASE + SLI_CTRL_I,
+		      SLI_AUTO_SEND_TRN_OFF | SLI_TRANS_EN);
+
+	reg = mmio_read_32(SLIH_CPU_BASE + SLI_CTRL_III);
+	reg &= ~(SLIH_PAD_DLY_RX1 | SLIH_PAD_DLY_RX0);
+	reg |= FIELD_PREP(SLIH_PAD_DLY_RX1, d1) |
+	       FIELD_PREP(SLIH_PAD_DLY_RX0, d0);
+	mmio_write_32(SLIH_CPU_BASE + SLI_CTRL_III, reg);
+	udelay(1);
+	mmio_write_32(SLIH_CPU_BASE + SLI_CTRL_I,
+		      SLI_CLEAR_BUS | SLI_TRANS_EN | SLI_CLEAR_RX);
+	sli_wait_suspend(SLIH_CPU_BASE);
+	printf("CPU SLIH[0] US win: {%d, %d} -> select %d\n", d0_start, d0_end, d0);
+	printf("CPU SLIH[1] US win: {%d, %d} -> select %d\n", win[d0][0], win[d0][1], d1);
+
+	/* Start SLIM training */
+	for (i = 0; i < 32; i++) {
+		win[i][0] = -1;
+		win[i][1] = -1;
+	}
+	for (d0 = 0; d0 < 16; d0++) {
+		/* set CPU SLIM US delay */
+		reg = mmio_read_32(SLIM_CPU_BASE + SLI_CTRL_III);
+		reg &= ~(SLIM_PAD_DLY_RX3 | SLIM_PAD_DLY_RX2 |
+			 SLIM_PAD_DLY_RX1 | SLIM_PAD_DLY_RX0);
+		reg |= FIELD_PREP(SLIM_PAD_DLY_RX3, d0) |
+		       FIELD_PREP(SLIM_PAD_DLY_RX2, d0) |
+		       FIELD_PREP(SLIM_PAD_DLY_RX1, d0) |
+		       FIELD_PREP(SLIM_PAD_DLY_RX0, d0);
+		mmio_write_32(SLIM_CPU_BASE + SLI_CTRL_III, reg);
+
+		/* reset IOD SLIM */
+		mmio_write_32(SLIM_IOD_BASE + SLI_CTRL_I, SLI_TRANS_EN | SLI_CLEAR_TX);
+		udelay(10);
+
+		/* training on, LAH disable, reset trigger */
+		mmio_write_32(SLIM_CPU_BASE + SLI_CTRL_I, SLI_TRANS_EN | SLI_CLEAR_RX);
+		udelay(10);
+
+		/* check interrupt status */
+		mmio_write_32(SLIM_CPU_BASE + SLI_INTR_STATUS, 0xffffffff);
+		if (is_sli_suspend(SLIM_CPU_BASE) > 0) {
+			if (win[0][0] == -1)
+				win[0][0] = d0;
+
+			win[0][1] = d0;
+		} else if (win[0][1] != -1) {
+			break;
+		}
+	}
+
+	d0 = (win[0][0] + win[0][1] + 1) >> 1;
+
+	mmio_write_32(SLIM_CPU_BASE + SLI_CTRL_I, SLI_AUTO_SEND_TRN_OFF | SLI_TRANS_EN);
+	reg = mmio_read_32(SLIM_CPU_BASE + SLI_CTRL_III);
+	reg &= ~(SLIM_PAD_DLY_RX3 | SLIM_PAD_DLY_RX2 | SLIM_PAD_DLY_RX1 |
+		 SLIM_PAD_DLY_RX0);
+	reg |= FIELD_PREP(SLIM_PAD_DLY_RX3, d0) |
+	       FIELD_PREP(SLIM_PAD_DLY_RX2, d0) |
+	       FIELD_PREP(SLIM_PAD_DLY_RX1, d0) |
+	       FIELD_PREP(SLIM_PAD_DLY_RX0, d0);
+	mmio_write_32(SLIM_CPU_BASE + SLI_CTRL_III, reg);
+
+	/* reset IOD SLIM */
+	mmio_write_32(SLIM_IOD_BASE + SLI_CTRL_I, SLI_TRANS_EN | SLI_CLEAR_TX);
+	udelay(1);
+	mmio_write_32(SLIM_CPU_BASE + SLI_CTRL_I,
+		      SLI_CLEAR_BUS | SLI_TRANS_EN | SLI_CLEAR_RX);
+	sli_wait_suspend(SLIM_CPU_BASE);
+	printf("IOD SLIM[3:0] US win: {%d, %d} -> select %d\n", win[0][0], win[0][1], d0);
+
+	/* Start SLIV training */
+	for (i = 0; i < 32; i++) {
+		win[i][0] = -1;
+		win[i][1] = -1;
+	}
+
+	/* set max wait count */
+	reg = mmio_read_32(SLIV_CPU_BASE + SLI_CTRL_II);
+	reg |= SLIV_TX_ENT_SUSPEND;
+	mmio_write_32(SLIV_CPU_BASE + SLI_CTRL_II, reg);
+	for (d0 = 0; d0 < 16; d0++) {
+		for (d1 = 0; d1 < 16; d1++) {
+			/* set IOD SLIM DS delay */
+			reg = mmio_read_32(SLIV_IOD_BASE + SLI_CTRL_III);
+			reg &= ~(SLIV_PAD_DLY_RX1 | SLIV_PAD_DLY_RX0);
+			reg |= FIELD_PREP(SLIV_PAD_DLY_RX1, d1) |
+			       FIELD_PREP(SLIV_PAD_DLY_RX0, d0);
+			mmio_write_32(SLIV_IOD_BASE + SLI_CTRL_III, reg);
+
+			/* reset SLIV */
+			mmio_write_32(SLIV_IOD_BASE + SLI_CTRL_I, 0x8021);
+			mmio_write_32(SLIV_CPU_BASE + SLI_CTRL_I, 0xc021);
+			udelay(100);
+
+			/* check interrupt status */
+			mmio_write_32(SLIV_IOD_BASE + SLI_INTR_STATUS, 0xffffffff);
+			if (is_sli_suspend(SLIV_IOD_BASE) > 0) {
+				if (win[d0][0] == -1)
+					win[d0][0] = d1;
+
+				win[d0][1] = d1;
+			} else if (win[d0][1] != -1) {
+				break;
+			}
+		}
+	}
+
+	d0_start = -1;
+	d0_end = -1;
+	for (i = 0; i < 32; i++) {
+		if (win[i][0] != -1) {
+			if (d0_start == -1)
+				d0_start = i;
+
+			d0_end = i;
+		} else if (d0_end != -1) {
+			break;
+		}
+	}
+
+	d0 = (d0_start + d0_end) >> 1;
+	d1 = (win[d0][0] + win[d0][1]) >> 1;
+
+	reg = mmio_read_32(SLIV_IOD_BASE + SLI_CTRL_III);
+	reg &= ~(SLIV_PAD_DLY_RX1 | SLIV_PAD_DLY_RX0);
+	reg |= FIELD_PREP(SLIV_PAD_DLY_RX1, d1) |
+	       FIELD_PREP(SLIV_PAD_DLY_RX0, d0);
+	mmio_write_32(SLIV_IOD_BASE + SLI_CTRL_III, reg);
+
+	mmio_write_32(SLIV_IOD_BASE + SLI_CTRL_I, 0x8061);
+	mmio_write_32(SLIV_CPU_BASE + SLI_CTRL_I, 0xc061);
+	sli_wait_suspend(SLIV_IOD_BASE);
+
+	/* clear CPU SLIV interrupt */
+	mmio_write_32(SLIV_IOD_BASE + SLI_INTR_STATUS, 0xffffffff);
+	mmio_write_32(SLIV_CPU_BASE + SLI_INTR_STATUS, 0xffffffff);
+	printf("IOD SLIV[0] DS win: {%d, %d} -> select %d\n", d0_start, d0_end, d0);
+	printf("IOD SLIV[1] DS win: {%d, %d} -> select %d\n", win[d0][0], win[d0][1], d1);
+}
+
 void bl31_platform_setup(void)
 {
+	generic_delay_timer_init();
+	bl31_plat_sli_init();
 	gicv3_driver_init(&plat_gic_data);
 	gicv3_distif_init();
 	gicv3_rdistif_init(plat_my_core_pos());
diff --git a/plat/aspeed/ast2700/platform.mk b/plat/aspeed/ast2700/platform.mk
index 873c60e20597..f6d86b54de69 100644
--- a/plat/aspeed/ast2700/platform.mk
+++ b/plat/aspeed/ast2700/platform.mk
@@ -18,6 +18,8 @@ BL31_SOURCES += \
 	plat/common/plat_gicv3.c		\
 	plat/common/plat_psci_common.c		\
 	drivers/ti/uart/aarch64/16550_console.S	\
+	drivers/delay_timer/delay_timer.c		\
+	drivers/delay_timer/generic_delay_timer.c	\
 	${PLAT_AST2700}/plat_helpers.S		\
 	${PLAT_AST2700}/plat_topology.c		\
 	${PLAT_AST2700}/plat_bl31_setup.c	\
-- 
2.25.1

