From 83917a020b0e0cbe5efcaed13fa67ab81b64ffc1 Mon Sep 17 00:00:00 2001
From: pengfu <peng.fu@rivai.ai>
Date: Wed, 5 Jun 2024 10:07:55 +0000
Subject: [PATCH] add debug info to ssif_bmc.c

---
 drivers/char/ipmi/ssif_bmc.c | 88 ++++++++++++++++++++++++++++++++----
 1 file changed, 80 insertions(+), 8 deletions(-)

diff --git a/drivers/char/ipmi/ssif_bmc.c b/drivers/char/ipmi/ssif_bmc.c
index 56346fb32872..2958dcee574a 100644
--- a/drivers/char/ipmi/ssif_bmc.c
+++ b/drivers/char/ipmi/ssif_bmc.c
@@ -137,15 +137,21 @@ static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count,
 	unsigned long flags;
 	ssize_t ret;
 
+	pr_info("%s: Entering ssif_bmc_read, count=%zu, ppos=%lld\n", DEVICE_NAME, count, *ppos);
+
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 	while (!ssif_bmc->request_available) {
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
+		if (file->f_flags & O_NONBLOCK) {
+			pr_info("%s: Non-blocking read with no available request\n", DEVICE_NAME);
 			return -EAGAIN;
+		}
 		ret = wait_event_interruptible(ssif_bmc->wait_queue,
 					       ssif_bmc->request_available);
-		if (ret)
+		if (ret) {
+			pr_info("%s: Interrupted while waiting for request\n", DEVICE_NAME);
 			return ret;
+		}
 		spin_lock_irqsave(&ssif_bmc->lock, flags);
 	}
 
@@ -154,6 +160,7 @@ static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count,
 			  sizeof(struct ipmi_ssif_msg))) {
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
 		ret = -EINVAL;
+		pr_info("%s: Buffer too small for read\n", DEVICE_NAME);
 	} else {
 		count = min_t(ssize_t,
 			      sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,
@@ -163,8 +170,13 @@ static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count,
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
 
 		ret = copy_to_user(buf, &msg, count);
+		if (ret) {
+			pr_info("%s: Failed to copy to user space, ret=%zd\n", DEVICE_NAME, ret);
+		}
 	}
 
+	pr_info("%s: Exiting ssif_bmc_read, ret=%zd\n", DEVICE_NAME, ret);
+
 	return (ret < 0) ? ret : count;
 }
 
@@ -177,24 +189,36 @@ static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t
 	unsigned long flags;
 	ssize_t ret;
 
-	if (count > sizeof(struct ipmi_ssif_msg))
+	pr_info("%s: Entering ssif_bmc_write, count=%zu, ppos=%lld\n", DEVICE_NAME, count, *ppos);
+
+	if (count > sizeof(struct ipmi_ssif_msg)) {
+		pr_info("%s: Write count exceeds max IPMI message size\n", DEVICE_NAME);
 		return -EINVAL;
+	}
 
-	if (copy_from_user(&msg, buf, count))
+	if (copy_from_user(&msg, buf, count)) {
+		pr_info("%s: Failed to copy from user space\n", DEVICE_NAME);
 		return -EFAULT;
+	}
 
-	if (!msg.len || count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len)
+	if (!msg.len || count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len) {
+		pr_info("%s: Invalid IPMI message length\n", DEVICE_NAME);
 		return -EINVAL;
+	}
 
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 	while (ssif_bmc->response_in_progress) {
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
+		if (file->f_flags & O_NONBLOCK) {
+			pr_info("%s: Non-blocking write with response in progress\n", DEVICE_NAME);
 			return -EAGAIN;
+		}
 		ret = wait_event_interruptible(ssif_bmc->wait_queue,
 					       !ssif_bmc->response_in_progress);
-		if (ret)
+		if (ret) {
+			pr_info("%s: Interrupted while waiting for response to complete\n", DEVICE_NAME);
 			return ret;
+		}
 		spin_lock_irqsave(&ssif_bmc->lock, flags);
 	}
 
@@ -204,8 +228,10 @@ static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t
 	 * Return -EINVAL if the response is aborted
 	 */
 	ret = (ssif_bmc->response_timer_inited) ? 0 : -EINVAL;
-	if (ret)
+	if (ret) {
+		pr_info("%s: Response timer not initialized\n", DEVICE_NAME);
 		goto exit;
+	}
 
 	del_timer(&ssif_bmc->response_timer);
 	ssif_bmc->response_timer_inited = false;
@@ -223,6 +249,8 @@ static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t
 exit:
 	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
 
+	pr_info("%s: Exiting ssif_bmc_write, ret=%zd\n", DEVICE_NAME, ret);
+
 	return (ret < 0) ? ret : count;
 }
 
@@ -231,6 +259,8 @@ static int ssif_bmc_open(struct inode *inode, struct file *file)
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 	int ret = 0;
 
+	pr_info("%s: Opening device\n", DEVICE_NAME);
+
 	spin_lock_irq(&ssif_bmc->lock);
 	if (!ssif_bmc->running)
 		ssif_bmc->running = 1;
@@ -238,6 +268,8 @@ static int ssif_bmc_open(struct inode *inode, struct file *file)
 		ret = -EBUSY;
 	spin_unlock_irq(&ssif_bmc->lock);
 
+	pr_info("%s: Device open, ret=%d\n", DEVICE_NAME, ret);
+
 	return ret;
 }
 
@@ -246,6 +278,8 @@ static __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 	__poll_t mask = 0;
 
+	pr_info("%s: Polling device\n", DEVICE_NAME);
+
 	poll_wait(file, &ssif_bmc->wait_queue, wait);
 
 	spin_lock_irq(&ssif_bmc->lock);
@@ -255,6 +289,8 @@ static __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)
 
 	spin_unlock_irq(&ssif_bmc->lock);
 
+	pr_info("%s: Device poll, mask=0x%x\n", DEVICE_NAME, mask);
+
 	return mask;
 }
 
@@ -262,10 +298,14 @@ static int ssif_bmc_release(struct inode *inode, struct file *file)
 {
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 
+	pr_info("%s: Releasing device\n", DEVICE_NAME);
+
 	spin_lock_irq(&ssif_bmc->lock);
 	ssif_bmc->running = 0;
 	spin_unlock_irq(&ssif_bmc->lock);
 
+	pr_info("%s: Device released\n", DEVICE_NAME);
+
 	return 0;
 }
 
@@ -284,6 +324,8 @@ static const struct file_operations ssif_bmc_fops = {
 /* Called with ssif_bmc->lock held. */
 static void complete_response(struct ssif_bmc_ctx *ssif_bmc)
 {
+	pr_info("%s: Completing response\n", DEVICE_NAME);
+
 	/* Invalidate response in buffer to denote it having been sent. */
 	ssif_bmc->response.len = 0;
 	ssif_bmc->response_in_progress = false;
@@ -299,6 +341,8 @@ static void response_timeout(struct timer_list *t)
 	struct ssif_bmc_ctx *ssif_bmc = from_timer(ssif_bmc, t, response_timer);
 	unsigned long flags;
 
+	pr_err("%s: Response timeout occurred\n", DEVICE_NAME);
+
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 
 	/* Do nothing if the response is in progress */
@@ -316,6 +360,8 @@ static void response_timeout(struct timer_list *t)
 /* Called with ssif_bmc->lock held. */
 static void handle_request(struct ssif_bmc_ctx *ssif_bmc)
 {
+	pr_info("%s: Handling request\n", DEVICE_NAME);
+
 	/* set ssif_bmc to busy waiting for response */
 	ssif_bmc->busy = true;
 	/* Request message is available to process */
@@ -472,6 +518,8 @@ static void handle_read_processed(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void handle_write_received(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	pr_info("%s: Handling write received, msg_idx=%d, val=0x%x\n", DEVICE_NAME, ssif_bmc->msg_idx, *val);
+
 	/*
 	 * The msg_idx must be 1 when first enter SSIF_REQ_RECVING state
 	 * And it would never exceeded 36 bytes included the 32 bytes max payload +
@@ -532,6 +580,7 @@ static bool validate_request_part(struct ssif_bmc_ctx *ssif_bmc)
 		ret = false;
 
 exit:
+	pr_info("%s: Validating request part, ret=%d\n", DEVICE_NAME, ret);
 	return ret;
 }
 
@@ -540,6 +589,8 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
 	unsigned int len;
 
+	pr_info("%s: Processing request part, smbus_cmd=0x%x, length=%u\n", DEVICE_NAME, part->smbus_cmd, part->length);
+
 	switch (part->smbus_cmd) {
 	case SSIF_IPMI_SINGLEPART_WRITE:
 		/* save the whole part to request*/
@@ -577,6 +628,8 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 static void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
 	/* SMBUS command can vary (single or multi-part) */
+	pr_info("%s: Processing SMBus command 0x%x\n", DEVICE_NAME, *val);
+
 	ssif_bmc->part_buf.smbus_cmd = *val;
 	ssif_bmc->msg_idx = 1;
 	memset(&ssif_bmc->part_buf.payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);
@@ -598,6 +651,8 @@ static void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	pr_info("%s: Read requested event in state=%s\n", DEVICE_NAME, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_REQ_RECVING ||
@@ -642,6 +697,8 @@ static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	pr_info("%s: Read processed event in state=%s\n", DEVICE_NAME, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_REQ_RECVING ||
@@ -665,6 +722,8 @@ static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	pr_info("%s: Write requested event in state=%s\n", DEVICE_NAME, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY || ssif_bmc->state == SSIF_SMBUS_CMD) {
 		ssif_bmc->state = SSIF_START;
 
@@ -684,6 +743,8 @@ static void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	pr_info("%s: Write received event in state=%s\n", DEVICE_NAME, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_RES_SENDING) {
 		dev_warn(&ssif_bmc->client->dev,
@@ -716,6 +777,8 @@ static void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	pr_info("%s: Stop event in state=%s\n", DEVICE_NAME, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_SMBUS_CMD ||
@@ -761,6 +824,8 @@ static int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8
 	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
 	int ret = 0;
 
+	pr_info("%s: I2C slave event %d\n", DEVICE_NAME, event);
+
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 
 	switch (event) {
@@ -802,10 +867,15 @@ static int ssif_bmc_probe(struct i2c_client *client)
 	struct ssif_bmc_ctx *ssif_bmc;
 	int ret;
 
+	pr_info("%s: Probing device\n", DEVICE_NAME);
+
 	ssif_bmc = devm_kzalloc(&client->dev, sizeof(*ssif_bmc), GFP_KERNEL);
 	if (!ssif_bmc)
 		return -ENOMEM;
 
+	pr_info("%s: I2C address: 0x%02x\n", DEVICE_NAME, client->addr);
+	pr_info("%s: Device name: %s\n", DEVICE_NAME, client->name);
+
 	spin_lock_init(&ssif_bmc->lock);
 
 	init_waitqueue_head(&ssif_bmc->wait_queue);
@@ -839,6 +909,8 @@ static void ssif_bmc_remove(struct i2c_client *client)
 {
 	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
 
+	pr_info("%s: Removing device\n", DEVICE_NAME);
+
 	i2c_slave_unregister(client);
 	misc_deregister(&ssif_bmc->miscdev);
 }
