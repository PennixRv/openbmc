From bf8ae0afd337393ad57ed5b70d31fcd3432995dd Mon Sep 17 00:00:00 2001
From: pengfu <peng.fu@rivai.ai>
Date: Fri, 7 Jun 2024 09:02:22 +0000
Subject: [PATCH] add debug info to ssif_bmc.c

---
 drivers/char/ipmi/ssif_bmc.c | 174 ++++++++++++++++++++++++++++-------
 1 file changed, 139 insertions(+), 35 deletions(-)

diff --git a/drivers/char/ipmi/ssif_bmc.c b/drivers/char/ipmi/ssif_bmc.c
index 56346fb32872..edde97770671 100644
--- a/drivers/char/ipmi/ssif_bmc.c
+++ b/drivers/char/ipmi/ssif_bmc.c
@@ -39,6 +39,8 @@
 #define SSIF_IPMI_MULTIPART_READ_START          0x3
 #define SSIF_IPMI_MULTIPART_READ_MIDDLE         0x9
 
+#include <linux/sched.h>  // For current
+
 /*
  * IPMI 2.0 Spec, section 12.7 SSIF Timing,
  * Request-to-Response Time is T6max(250ms) - T1max(20ms) - 3ms = 227ms
@@ -137,15 +139,21 @@ static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count,
 	unsigned long flags;
 	ssize_t ret;
 
+	// pr_info("%s: [%-20s] Entering ssif_bmc_read, count=%zu, ppos=%lld\n", DEVICE_NAME, current->comm, count, *ppos);
+
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 	while (!ssif_bmc->request_available) {
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
+		if (file->f_flags & O_NONBLOCK) {
+			// pr_info("%s: [%-20s] Non-blocking read with no available request\n", DEVICE_NAME, current->comm);
 			return -EAGAIN;
+		}
 		ret = wait_event_interruptible(ssif_bmc->wait_queue,
 					       ssif_bmc->request_available);
-		if (ret)
+		if (ret) {
+			// pr_info("%s: [%-20s] Interrupted while waiting for request\n", DEVICE_NAME, current->comm);
 			return ret;
+		}
 		spin_lock_irqsave(&ssif_bmc->lock, flags);
 	}
 
@@ -154,6 +162,7 @@ static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count,
 			  sizeof(struct ipmi_ssif_msg))) {
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
 		ret = -EINVAL;
+		// pr_info("%s: [%-20s] Buffer too small for read\n", DEVICE_NAME, current->comm);
 	} else {
 		count = min_t(ssize_t,
 			      sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,
@@ -163,8 +172,20 @@ static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count,
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
 
 		ret = copy_to_user(buf, &msg, count);
+		if (ret) {
+			// pr_info("%s: [%-20s] Failed to copy to user space, ret=%zd\n", DEVICE_NAME, current->comm, ret);
+		}else {
+            // Print the data buffer content in hexadecimal format
+            pr_info("%s: [%-20s] Data buffer content (hex): ", DEVICE_NAME, current->comm);
+            for (size_t i = 0; i < count; ++i) {
+                pr_cont("%02x ", ((unsigned char *)&msg)[i]);
+            }
+            pr_cont("\n");
+        }
 	}
 
+	// pr_info("%s: [%-20s] Exiting ssif_bmc_read, ret=%zd\n", DEVICE_NAME, current->comm, ret);
+
 	return (ret < 0) ? ret : count;
 }
 
@@ -176,36 +197,57 @@ static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t
 	struct ipmi_ssif_msg msg;
 	unsigned long flags;
 	ssize_t ret;
+	char byte;
+
+	// pr_info("%s: [%-20s] Entering ssif_bmc_write, count=%zu, ppos=%lld\n", DEVICE_NAME, current->comm, count, *ppos);
 
-	if (count > sizeof(struct ipmi_ssif_msg))
+	pr_info("%s: [%-20s] Data buffer content (hex): ", DEVICE_NAME, current->comm);
+	for (size_t i = 0; i < count; ++i) {
+		if (get_user(byte, &buf[i])) {
+			// pr_info("\n%s: [%-20s] Error accessing user memory\n", DEVICE_NAME, current->comm);
+			return -EFAULT;
+		}
+		pr_cont("%02x ", (unsigned char)byte);
+	}
+	pr_cont("\n");
+
+
+	if (count > sizeof(struct ipmi_ssif_msg)) {
+		// pr_info("%s: [%-20s] Write count exceeds max IPMI message size\n", DEVICE_NAME, current->comm);
 		return -EINVAL;
+	}
 
-	if (copy_from_user(&msg, buf, count))
+	if (copy_from_user(&msg, buf, count)) {
+		// pr_info("%s: [%-20s] Failed to copy from user space\n", DEVICE_NAME, current->comm);
 		return -EFAULT;
+	}
 
-	if (!msg.len || count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len)
+	if (!msg.len || count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len) {
+		// pr_info("%s: [%-20s] Invalid IPMI message length\n", DEVICE_NAME, current->comm);
 		return -EINVAL;
+	}
 
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 	while (ssif_bmc->response_in_progress) {
 		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
+		if (file->f_flags & O_NONBLOCK) {
+			// pr_info("%s: [%-20s] Non-blocking write with response in progress\n", DEVICE_NAME, current->comm);
 			return -EAGAIN;
+		}
 		ret = wait_event_interruptible(ssif_bmc->wait_queue,
 					       !ssif_bmc->response_in_progress);
-		if (ret)
+		if (ret) {
+			// pr_info("%s: [%-20s] Interrupted while waiting for response to complete\n", DEVICE_NAME, current->comm);
 			return ret;
+		}
 		spin_lock_irqsave(&ssif_bmc->lock, flags);
 	}
 
-	/*
-	 * The write must complete before the response timeout fired, otherwise
-	 * the response is aborted and wait for next request
-	 * Return -EINVAL if the response is aborted
-	 */
 	ret = (ssif_bmc->response_timer_inited) ? 0 : -EINVAL;
-	if (ret)
+	if (ret) {
+		// pr_info("%s: [%-20s] Response timer not initialized\n", DEVICE_NAME, current->comm);
 		goto exit;
+	}
 
 	del_timer(&ssif_bmc->response_timer);
 	ssif_bmc->response_timer_inited = false;
@@ -215,22 +257,25 @@ static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t
 
 	ssif_bmc->response_in_progress = true;
 
-	/* ssif_bmc not busy */
 	ssif_bmc->busy = false;
 
-	/* Clean old request buffer */
 	memset(&ssif_bmc->request, 0, sizeof(struct ipmi_ssif_msg));
 exit:
 	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
 
+	// pr_info("%s: [%-20s] Exiting ssif_bmc_write, ret=%zd\n", DEVICE_NAME, current->comm, ret);
+
 	return (ret < 0) ? ret : count;
 }
 
+
 static int ssif_bmc_open(struct inode *inode, struct file *file)
 {
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 	int ret = 0;
 
+	// pr_info("%s: [%-20s] Opening device\n", DEVICE_NAME, current->comm);
+
 	spin_lock_irq(&ssif_bmc->lock);
 	if (!ssif_bmc->running)
 		ssif_bmc->running = 1;
@@ -238,6 +283,8 @@ static int ssif_bmc_open(struct inode *inode, struct file *file)
 		ret = -EBUSY;
 	spin_unlock_irq(&ssif_bmc->lock);
 
+	// pr_info("%s: [%-20s] Device open, ret=%d\n", DEVICE_NAME, current->comm, ret);
+
 	return ret;
 }
 
@@ -246,6 +293,8 @@ static __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 	__poll_t mask = 0;
 
+	// pr_info("%s: [%-20s] Polling device\n", DEVICE_NAME, current->comm);
+
 	poll_wait(file, &ssif_bmc->wait_queue, wait);
 
 	spin_lock_irq(&ssif_bmc->lock);
@@ -255,6 +304,8 @@ static __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)
 
 	spin_unlock_irq(&ssif_bmc->lock);
 
+	// pr_info("%s: [%-20s] Device poll, mask=0x%x\n", DEVICE_NAME, current->comm, mask);
+
 	return mask;
 }
 
@@ -262,10 +313,14 @@ static int ssif_bmc_release(struct inode *inode, struct file *file)
 {
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 
+	// pr_info("%s: [%-20s] Releasing device\n", DEVICE_NAME, current->comm);
+
 	spin_lock_irq(&ssif_bmc->lock);
 	ssif_bmc->running = 0;
 	spin_unlock_irq(&ssif_bmc->lock);
 
+	// pr_info("%s: [%-20s] Device released\n", DEVICE_NAME, current->comm);
+
 	return 0;
 }
 
@@ -284,6 +339,8 @@ static const struct file_operations ssif_bmc_fops = {
 /* Called with ssif_bmc->lock held. */
 static void complete_response(struct ssif_bmc_ctx *ssif_bmc)
 {
+	// pr_info("%s: [%-20s] Completing response\n", DEVICE_NAME, current->comm);
+
 	/* Invalidate response in buffer to denote it having been sent. */
 	ssif_bmc->response.len = 0;
 	ssif_bmc->response_in_progress = false;
@@ -299,6 +356,8 @@ static void response_timeout(struct timer_list *t)
 	struct ssif_bmc_ctx *ssif_bmc = from_timer(ssif_bmc, t, response_timer);
 	unsigned long flags;
 
+	pr_err("%s: [%-20s] Response timeout occurred\n", DEVICE_NAME, current->comm);
+
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 
 	/* Do nothing if the response is in progress */
@@ -316,6 +375,8 @@ static void response_timeout(struct timer_list *t)
 /* Called with ssif_bmc->lock held. */
 static void handle_request(struct ssif_bmc_ctx *ssif_bmc)
 {
+	// pr_info("%s: [%-20s] Handling request\n", DEVICE_NAME, current->comm);
+
 	/* set ssif_bmc to busy waiting for response */
 	ssif_bmc->busy = true;
 	/* Request message is available to process */
@@ -425,8 +486,8 @@ static void set_multipart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
 
 	default:
 		/* Do not expect to go to this case */
-		dev_err(&ssif_bmc->client->dev, "%s: Unexpected SMBus command 0x%x\n",
-			__func__, part->smbus_cmd);
+		dev_err(&ssif_bmc->client->dev, "%s: [%-20s] Unexpected SMBus command 0x%x\n",
+			__func__, current->comm, part->smbus_cmd);
 		break;
 	}
 
@@ -472,6 +533,8 @@ static void handle_read_processed(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void handle_write_received(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	// pr_info("%s: [%-20s] Handling write received, msg_idx=%d, val=0x%x\n", DEVICE_NAME, current->comm, ssif_bmc->msg_idx, *val);
+
 	/*
 	 * The msg_idx must be 1 when first enter SSIF_REQ_RECVING state
 	 * And it would never exceeded 36 bytes included the 32 bytes max payload +
@@ -532,6 +595,7 @@ static bool validate_request_part(struct ssif_bmc_ctx *ssif_bmc)
 		ret = false;
 
 exit:
+	// pr_info("%s: [%-20s] Validating request part, ret=%d\n", DEVICE_NAME, current->comm, ret);
 	return ret;
 }
 
@@ -540,6 +604,8 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
 	unsigned int len;
 
+	// pr_info("%s: [%-20s] Processing request part, smbus_cmd=0x%x, length=%u\n", DEVICE_NAME, current->comm, part->smbus_cmd, part->length);
+
 	switch (part->smbus_cmd) {
 	case SSIF_IPMI_SINGLEPART_WRITE:
 		/* save the whole part to request*/
@@ -568,8 +634,8 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 		break;
 	default:
 		/* Do not expect to go to this case */
-		dev_err(&ssif_bmc->client->dev, "%s: Unexpected SMBus command 0x%x\n",
-			__func__, part->smbus_cmd);
+		dev_err(&ssif_bmc->client->dev, "%s: [%-20s] Unexpected SMBus command 0x%x\n",
+			__func__, current->comm, part->smbus_cmd);
 		break;
 	}
 }
@@ -577,6 +643,8 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 static void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
 	/* SMBUS command can vary (single or multi-part) */
+	// pr_info("%s: [%-20s] Processing SMBus command 0x%x\n", DEVICE_NAME, current->comm, *val);
+
 	ssif_bmc->part_buf.smbus_cmd = *val;
 	ssif_bmc->msg_idx = 1;
 	memset(&ssif_bmc->part_buf.payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);
@@ -598,21 +666,23 @@ static void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	// pr_info("%s: [%-20s] Read requested event in state=%s\n", DEVICE_NAME, current->comm, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_REQ_RECVING ||
 	    ssif_bmc->state == SSIF_RES_SENDING) {
 		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected READ REQUESTED in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
+			 "Warn: %s [%-20s] unexpected READ REQUESTED in state=%s\n",
+			 __func__, current->comm, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_ABORTING;
 		*val = 0;
 		return;
 
 	} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {
 		if (!supported_read_cmd(ssif_bmc->part_buf.smbus_cmd)) {
-			dev_warn(&ssif_bmc->client->dev, "Warn: Unknown SMBus read command=0x%x",
-				 ssif_bmc->part_buf.smbus_cmd);
+			dev_warn(&ssif_bmc->client->dev, "Warn: [%-20s] Unknown SMBus read command=0x%x",
+				 current->comm, ssif_bmc->part_buf.smbus_cmd);
 			ssif_bmc->aborting = true;
 		}
 
@@ -642,13 +712,15 @@ static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	// pr_info("%s: [%-20s] Read processed event in state=%s\n", DEVICE_NAME, current->comm, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_REQ_RECVING ||
 	    ssif_bmc->state == SSIF_SMBUS_CMD) {
 		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected READ PROCESSED in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
+			 "Warn: %s [%-20s] unexpected READ PROCESSED in state=%s\n",
+			 __func__, current->comm, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_ABORTING;
 		*val = 0;
 		return;
@@ -665,6 +737,8 @@ static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	// pr_info("%s: [%-20s] Write requested event in state=%s\n", DEVICE_NAME, current->comm, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY || ssif_bmc->state == SSIF_SMBUS_CMD) {
 		ssif_bmc->state = SSIF_START;
 
@@ -672,8 +746,8 @@ static void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 		   ssif_bmc->state == SSIF_REQ_RECVING ||
 		   ssif_bmc->state == SSIF_RES_SENDING) {
 		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected WRITE REQUEST in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
+			 "Warn: %s [%-20s] unexpected WRITE REQUEST in state=%s\n",
+			 __func__, current->comm, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_ABORTING;
 		return;
 	}
@@ -684,11 +758,13 @@ static void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	// pr_info("%s: [%-20s] Write received event in state=%s\n", DEVICE_NAME, current->comm, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_RES_SENDING) {
 		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected WRITE RECEIVED in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
+			 "Warn: %s [%-20s] unexpected WRITE RECEIVED in state=%s\n",
+			 __func__, current->comm, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_ABORTING;
 
 	} else if (ssif_bmc->state == SSIF_START) {
@@ -696,8 +772,8 @@ static void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 	} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {
 		if (!supported_write_cmd(ssif_bmc->part_buf.smbus_cmd)) {
-			dev_warn(&ssif_bmc->client->dev, "Warn: Unknown SMBus write command=0x%x",
-				 ssif_bmc->part_buf.smbus_cmd);
+			dev_warn(&ssif_bmc->client->dev, "Warn: [%-20s] Unknown SMBus write command=0x%x",
+				 current->comm, ssif_bmc->part_buf.smbus_cmd);
 			ssif_bmc->aborting = true;
 		}
 
@@ -716,13 +792,15 @@ static void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	// pr_info("%s: [%-20s] Stop event in state=%s\n", DEVICE_NAME, current->comm, state_to_string(ssif_bmc->state));
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_SMBUS_CMD ||
 	    ssif_bmc->state == SSIF_ABORTING) {
 		dev_warn(&ssif_bmc->client->dev,
-			 "Warn: %s unexpected SLAVE STOP in state=%s\n",
-			 __func__, state_to_string(ssif_bmc->state));
+			 "Warn: %s [%-20s] unexpected SLAVE STOP in state=%s\n",
+			 __func__, current->comm, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_READY;
 
 	} else if (ssif_bmc->state == SSIF_REQ_RECVING) {
@@ -738,7 +816,7 @@ static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 			 * transaction and any further transactions (read or write) until
 			 * the next valid read or write Start transaction is received
 			 */
-			dev_err(&ssif_bmc->client->dev, "Error: invalid pec\n");
+			dev_err(&ssif_bmc->client->dev, "Error: [%-20s] invalid pec\n", current->comm);
 			ssif_bmc->aborting = true;
 		}
 	} else if (ssif_bmc->state == SSIF_RES_SENDING) {
@@ -752,6 +830,23 @@ static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 	ssif_bmc->msg_idx = 0;
 }
 
+static const char* i2c_slave_event_to_string(enum i2c_slave_event event) {
+    switch (event) {
+        case I2C_SLAVE_READ_REQUESTED:
+            return "I2C_SLAVE_READ_REQUESTED";
+        case I2C_SLAVE_WRITE_REQUESTED:
+            return "I2C_SLAVE_WRITE_REQUESTED";
+        case I2C_SLAVE_READ_PROCESSED:
+            return "I2C_SLAVE_READ_PROCESSED";
+        case I2C_SLAVE_WRITE_RECEIVED:
+            return "I2C_SLAVE_WRITE_RECEIVED";
+        case I2C_SLAVE_STOP:
+            return "I2C_SLAVE_STOP";
+        default:
+            return "Unknown event";
+    }
+}
+
 /*
  * Callback function to handle I2C slave events
  */
@@ -761,6 +856,8 @@ static int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8
 	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
 	int ret = 0;
 
+	// pr_info("%s: [%-20s] I2C slave event --> (%s)\n", DEVICE_NAME, current->comm, i2c_slave_event_to_string(event));
+
 	spin_lock_irqsave(&ssif_bmc->lock, flags);
 
 	switch (event) {
@@ -785,7 +882,7 @@ static int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8
 		break;
 
 	default:
-		dev_warn(&ssif_bmc->client->dev, "Warn: Unknown i2c slave event\n");
+		dev_warn(&ssif_bmc->client->dev, "Warn: [%-20s] Unknown i2c slave event\n", current->comm);
 		break;
 	}
 
@@ -802,10 +899,15 @@ static int ssif_bmc_probe(struct i2c_client *client)
 	struct ssif_bmc_ctx *ssif_bmc;
 	int ret;
 
+	// pr_info("%s: [%-20s] Probing device\n", DEVICE_NAME, current->comm);
+
 	ssif_bmc = devm_kzalloc(&client->dev, sizeof(*ssif_bmc), GFP_KERNEL);
 	if (!ssif_bmc)
 		return -ENOMEM;
 
+	// pr_info("%s: [%-20s] I2C address: 0x%02x\n", DEVICE_NAME, current->comm, client->addr);
+	// pr_info("%s: [%-20s] Device name: %s\n", DEVICE_NAME, current->comm, client->name);
+
 	spin_lock_init(&ssif_bmc->lock);
 
 	init_waitqueue_head(&ssif_bmc->wait_queue);
@@ -839,6 +941,8 @@ static void ssif_bmc_remove(struct i2c_client *client)
 {
 	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
 
+	// pr_info("%s: [%-20s] Removing device\n", DEVICE_NAME, current->comm);
+
 	i2c_slave_unregister(client);
 	misc_deregister(&ssif_bmc->miscdev);
 }
