From 9285a59f0f07fc50be4ed2ed39c5adbeaa9eee4e Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Wed, 5 Jun 2024 02:48:16 +0000
Subject: [PATCH] add debug code for host-cmd-manager.cpp

---
 host-cmd-manager.cpp | 39 ++++++++++++++++++++++++++-------------
 1 file changed, 26 insertions(+), 13 deletions(-)

diff --git a/host-cmd-manager.cpp b/host-cmd-manager.cpp
index c539aa2..61384c3 100644
--- a/host-cmd-manager.cpp
+++ b/host-cmd-manager.cpp
@@ -39,12 +39,14 @@ Manager::Manager(sdbusplus::bus_t& bus) :
         sdbusRule::propertiesChanged(HOST_STATE_PATH, HOST_STATE_INTERFACE),
         std::bind(&Manager::clearQueueOnPowerOn, this, std::placeholders::_1))
 {
-    // Nothing to do here.
+    log<level::DEBUG>("Host Cmd Manager initialized");
 }
 
 // Called as part of READ_MSG_DATA command
 IpmiCmdData Manager::getNextCommand()
 {
+    log<level::DEBUG>("Attempting to get next command from the queue");
+
     // Stop the timer. Don't have to Err failure doing so.
     auto r = timer.stop();
     if (r < 0)
@@ -55,16 +57,14 @@ IpmiCmdData Manager::getNextCommand()
 
     if (this->workQueue.empty())
     {
-        // Just return a heartbeat in this case.  A spurious SMS_ATN was
-        // asserted for the host (probably from a previous boot).
-        log<level::DEBUG>("Control Host work queue is empty!");
-
+        log<level::DEBUG>("Control Host work queue is empty! Returning heartbeat");
         return std::make_pair(CMD_HEARTBEAT, 0x00);
     }
 
     // Pop the processed entry off the queue
     auto command = this->workQueue.front();
     this->workQueue.pop();
+    log<level::DEBUG>("Command dequeued", entry("COMMAND_ID=%d", std::get<0>(command).first));
 
     // IPMI command is the first element in pair
     auto ipmiCmdData = std::get<0>(command);
@@ -74,6 +74,8 @@ IpmiCmdData Manager::getNextCommand()
     // can be sent. `true` indicating Success.
     std::get<CallBack>(command)(ipmiCmdData, true);
 
+    log<level::DEBUG>("Command processed successfully", entry("COMMAND_ID=%d", std::get<0>(command).first));
+
     // Check for another entry in the queue and kick it off
     this->checkQueueAndAlertHost();
 
@@ -84,18 +86,20 @@ IpmiCmdData Manager::getNextCommand()
 // Called when initial timer goes off post sending SMS_ATN
 void Manager::hostTimeout()
 {
-    log<level::ERR>("Host control timeout hit!");
-
+    log<level::ERR>("Host control timeout hit! Clearing the queue.");
     clearQueue();
 }
 
 void Manager::clearQueue()
 {
+    log<level::INFO>("Clearing command queue due to timeout or power on");
+
     // Dequeue all entries and send fail signal
     while (!this->workQueue.empty())
     {
         auto command = this->workQueue.front();
         this->workQueue.pop();
+        log<level::DEBUG>("Dequeued and failed command", entry("COMMAND_ID=%d", std::get<0>(command).first));
 
         // IPMI command is the first element in pair
         auto ipmiCmdData = std::get<0>(command);
@@ -109,9 +113,11 @@ void Manager::clearQueue()
 // Called for alerting the host
 void Manager::checkQueueAndAlertHost()
 {
+    log<level::DEBUG>("Checking queue and possibly alerting host");
+
     if (this->workQueue.size() >= 1)
     {
-        log<level::DEBUG>("Asserting SMS Attention");
+        log<level::INFO>("Asserting SMS Attention due to command in queue");
 
         std::string HOST_IPMI_SVC("org.openbmc.HostIpmi");
         std::string IPMI_PATH("/org/openbmc/HostIpmi/1");
@@ -135,23 +141,26 @@ void Manager::checkQueueAndAlertHost()
         try
         {
             auto reply = this->bus.call(method);
-
-            log<level::DEBUG>("SMS Attention asserted");
+            log<level::DEBUG>("SMS Attention asserted successfully");
         }
         catch (sdbusplus::exception_t& e)
         {
-            log<level::ERR>("Error when call setAttention method");
+            log<level::ERR>("Error when calling setAttention method", entry("ERROR_MSG=%s", e.what()));
         }
     }
+    else
+    {
+        log<level::DEBUG>("No need to alert host, queue is empty or command is in process");
+    }
 }
 
 // Called by specific implementations that provide commands
 void Manager::execute(CommandHandler command)
 {
-    log<level::DEBUG>("Pushing cmd on to queue",
-                      entry("COMMAND=%d", std::get<0>(command).first));
+    log<level::DEBUG>("Executing command", entry("COMMAND_ID=%d", std::get<0>(command).first));
 
     this->workQueue.emplace(command);
+    log<level::DEBUG>("Command pushed onto queue", entry("QUEUE_SIZE=%d", this->workQueue.size()));
 
     // Alert host if this is only command in queue otherwise host will
     // be notified of next message after processing the current one
@@ -169,6 +178,8 @@ void Manager::execute(CommandHandler command)
 
 void Manager::clearQueueOnPowerOn(sdbusplus::message_t& msg)
 {
+    log<level::DEBUG>("Host power state changed, checking for queue clear conditions");
+
     namespace server = sdbusplus::server::xyz::openbmc_project::state;
 
     ::ipmi::DbusInterface interface;
@@ -178,6 +189,7 @@ void Manager::clearQueueOnPowerOn(sdbusplus::message_t& msg)
 
     if (properties.find(HOST_TRANS_PROP) == properties.end())
     {
+        log<level::DEBUG>("No transition property change detected, returning early");
         return;
     }
 
@@ -187,6 +199,7 @@ void Manager::clearQueueOnPowerOn(sdbusplus::message_t& msg)
     if (server::Host::convertTransitionFromString(requestedState) ==
         server::Host::Transition::On)
     {
+        log<level::INFO>("Host transition to ON detected, clearing command queue");
         clearQueue();
     }
 }
